<유클리드 호제법>
  : 2개의 자연수 또는 정시의 최대공약수를 구하는 알고리즘
  호제법이라는 말은 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘

  2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a>b), 
  a와 b의 최대공약수는 b와 r의 최대공약수와 같다.
  
  ex)
    def gcd(a, b):
      while b > 0:
        a, b = b, a % b
      return a

  (최대공약수)
    a * b = GGx*y
    a * b / G = GGx*y / G (양변에 최소 공약수를 나누어 줌)
    a * b / G = Gxy(최소공배수)
    최소공배수 = a * b / G

    ex)
      def lcm(a, b):
        return a * b // gcd(a, b)


<정렬 알고리즘>
  : 데이터를 특정한 기준에 따라 순서대로 나열하는 것


  1. 버블 정렬
    : 인접한 두 수를 비교하며 정렬해나간는 방법으로 O(n^2)의 느린 성능을 가지고 있다.

      1. 앞에서부터 시작하여 큰 수를 뒤로 보내 뒤가 가장 큰 값을 가지도록 완성해가는 방법
      2. 뒤에서부터 반복하여 앞의 작은 값부터 정렬을 완성해 나가는 방법

      ex)
        array = [9,8,7,6,5,4,3,2,1]

        def bubble_sort(array):
            n = len(array)
            for i in range(n - 1):
                for j in range(n - i - 1):
                    if array[j] > array[j + 1]:
                        array[j], array[j + 1] = array[j + 1], array[j]
                print(array)
        print("before: ",array)
        bubble_sort(array)
        print("after:", array)
  

  2. 선택 정렬
    : 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복한다. 
      선택 정렬의 시간복잡도 : O(N^2)

      ex)
        array = [8,4,6,2,9,1,3,7,5]

        def selection_sort(array):
          n = len(array)
          for i in range(n):
            min_index = i
            for j in range(i + 1, n):
              if array[j] < array[min_index]:
                min_index = j
            array[i], array[min_index] =  array[min_index], array[i]
            print(array[:i+1])

        print("before: ",array)
        selection_sort(array)
        print("after:", array)


  3.삽입 정렬
    : 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
      (선택 정렬에 비해 구현 난이도가 높지만, 일반적으로 더 효율적이다.)

      삽입 정렬의 시간복잡도 : O(N^2) 단 최상의 경우 O(N)이 됨

      ex)
        array = [8,4,6,2,9,1,3,7,5]

        def insertion_sort(array):
          n = len(array)
          for i in range(1, n):
            for j in range(i, 0, - 1):
              if array[j - 1] > array[j]:
                array[j - 1], array[j] = array[j], array[j - 1]
            print(array[:i+1])

        print("before: ",array)
        insertion_sort(array)
        print("after:", array)


  4. 병합 정렬
    : 분할 정복과 재귀를 이용한 알고리즘으로 O(NlogN)의 속도이다.
      반으로 쪼개고 다시 합치는 과정에서 그룹을 만들어 정렬하게 되며 이 과정에서
      2n개의 공간이 필요하다.
    
    ex)
      array = [8,4,6,2,9,1,3,7,5]

      def merge_sort(array):
        if len(array) < 2:
          return array
        mid = len(array) // 2
        low_arr = merge_sort(array[:mid])
        high_arr = merge_sort(array[mid:])

        merged_arr = []
        l = h = 0
        while l < len(low_arr) and h < len(high_arr):
          if low_arr[l] < high_arr[h]:
            merged_arr.append(low_arr[l])
            l += 1
          else:
            merged_arr.append(high_arr[h])
            h += 1
        merged_arr += low_arr[l:]
        merged_arr += high_arr[h:]
        print(merged_arr)
        return merged_arr

      print("before: ",array)
      array = merge_sort(array)
      print("after:", array)


  5. 퀵 정렬
    : 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법.
    
    일반적인 상황에서 가장 많이 사용됨
    병합 정렬과 함께 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 됨
    가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터로 설정

    퀵 정렬의 시간복잡도 : O(NlogN) 단 최악의 경우 O(N^2)의 시간복잡도를 갖는다.

  5. 계수 정렬


<그리디 알고리즘 (탐욕법)>
  : 그리디 알고리즘은 현재 상황에서 지금 당장 좋은 것만 고르는 방법

  코딩 테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이 를 추론할 수 있어야 풀리도록 출제된다.

  검증 종류가 K개라고 할때, 소스코드의 시간 복잡도는 O(K)이다.
