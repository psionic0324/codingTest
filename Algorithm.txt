<그리디 알고리즘 (탐욕법)>
  : 그리디 알고리즘은 현재 상황에서 지금 당장 좋은 것만 고르는 방법
  
  코딩 테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이 를 추론할 수 있어야 풀리도록 출제된다.

  검증 종류가 K개라고 할때, 소스코드의 시간 복잡도는 O(K)이다.

<정렬 알고리즘>
  : 데이터를 특정한 기준에 따라 순서대로 나열하는 것

  1. 선택 정렬
    : 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복한다. 

    선택 정렬의 시간복잡도 : O(N^2)

  2.삽입 정렬
    : 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입한다.
    (선택 정렬에 비해 구현 난이도가 높지만, 일반적으로 더 효율적이다.)

    삽입 정렬의 시간복잡도 : O(N^2) 단 최상의 경우 O(N)이 됨

  3. 퀵 정렬
    : 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법.
    
    일반적인 상황에서 가장 많이 사용됨
    병합 정렬과 함께 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 됨
    가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터로 설정

    퀵 정렬의 시간복잡도 : O(NlogN) 단 최악의 경우 O(N^2)의 시간복잡도를 갖는다.

  4. 계수 정렬

<유클리드 호제법>
  : 2개의 자연수 또는 정시의 최대공약수를 구하는 알고리즘
  호제법이라는 말은 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘

  2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a>b), 
  a와 b의 최대공약수는 b와 r의 최대공약수와 같다.
  
  ex)
    def gcd(a, b):
      while b > 0:
        a, b = b, a % b
      return a

  (최대공약수)
    a * b = GGx*y
    a * b / G = GGx*y / G (양변에 최소 공약수를 나누어 줌)
    a * b / G = Gxy(최소공배수)
    최소공배수 = a * b / G

    ex)
      def lcm(a, b):
        return a * b // gcd(a, b)